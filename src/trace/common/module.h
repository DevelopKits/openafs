/*
 * Copyright 2006-2007, Sine Nomine Associates and others.
 * All Rights Reserved.
 * 
 * This software has been released under the terms of the IBM Public
 * License.  For details, see the LICENSE file in the top-level source
 * directory or online at http://www.openafs.org/dl/license10.html
 */

#ifndef _OSI_TRACE_COMMON_MODULE_H
#define _OSI_TRACE_COMMON_MODULE_H 1

/*
 * base tracepoints for AFS
 *
 * these tracepoints are common across all AFS components
 */

#include <osi/osi_list.h>

#define OSI_TRACE_MODULE_NAME_LEN_MAX     64
#define OSI_TRACE_MODULE_PREFIX_LEN_MAX  256

typedef osi_uint32 osi_trace_module_id_t;

typedef struct {
    osi_trace_module_id_t id;
    osi_uint32 version;
    osi_uint32 probe_count;
    char name[OSI_TRACE_MODULE_NAME_LEN_MAX];
    char prefix[OSI_TRACE_MODULE_PREFIX_LEN_MAX];
} osi_trace_module_info_t;

typedef struct {
    osi_list_element_volatile module_list;
    osi_trace_module_id_t id;
    osi_uint32 version;
    osi_uint32 probe_count;
    char * name;
    char * prefix;
} osi_trace_module_header_t;

typedef enum {
    OSI_TRACE_MODULE_CKSUM_TYPE_NONE,
    OSI_TRACE_MODULE_CKSUM_TYPE_SUM,
    OSI_TRACE_MODULE_CKSUM_TYPE_MD5,
    OSI_TRACE_MODULE_CKSUM_TYPE_MAX_ID
} osi_trace_module_cksum_type_t;

#define OSI_TRACE_PROBE_DECL(x) osi_trace_probe_id_t x


/*
 * module-specific tracepoint support
 *
 * It is expected that many tracepoints will be very specific to a given application.
 * So as to not pollute the tracepoint namespace, we are providing support for tracepoints
 * which are only registered and defined in certain applications.
 *
 * for the common case, table-gen.awk should do everything for you.  Here's what the
 * autogenerated code will look like:
 *
 * in header file:
 *
 *   #define osi_Trace_Vol_ProbeId(probe) osi_Trace_Module_ProbeId(Vol, probe)
 *
 *   osi_Trace_Module_TracePoint_Table_Def_Begin(Vol) {
 *       osi_trace_module_header_t header;
 *       OSI_TRACE_PROBE_DECL(vol_change_state);
 *       OSI_TRACE_PROBE_DECL(vol_attach_start);
 *       OSI_TRACE_PROBE_DECL(vol_attach_end);
 *   } osi_Trace_Module_TracePoint_Table_Def_End(Vol);
 *
 * in implementation file:
 *
 *   #define OSI_TRACE_PROBE_REGISTER(handle, id, name, mode) \
 *       osi_Macro_Begin \
 *           osi_result _res; \
 *           _res = osi_trace_probe_register(&(handle), &osi_Trace_Vol_ProbeId(probe), (mode)); \
 *           if (OSI_RESULT_OK_LIKELY(_res)) { \
 *               osi_trace_directory_probe_register((name), (handle)); \
 *           } \
 *       osi_Macro_End
 *
 *   osi_Trace_Module_Tracepoint_Table_Decl(Vol);
 *
 *   osi_result
 *   VInitVolumeTrace(void) {
 *       osi_trace_probe_t handle;
 *       osi_mem_zero(&osi_Trace_Module_Table_Name(Vol), sizeof(osi_Trace_Module_Table_Name(Vol)));
 *       OSI_TRACE_PROBE_REGISTER(handle, vol_change_state, "afs.vol.volume.change_state", 0);
 *       OSI_TRACE_PROBE_REGISTER(handle, vol_attach_start, "afs.vol.volume.attach.start", 1);
 *       OSI_TRACE_PROBE_REGISTER(handle, vol_attach_end, "afs.vol.volume.attach.end", 0);
 *       return OSI_OK;
 *   }
 *
 *  the argument of 1 for mode of vol_attach_start causes the probe to register in an initially
 *  enabled state
 */

#define osi_Trace_Module_Table_Name(m) osi_tracepoint_table_mod_##m
#define osi_Trace_Module_ProbeId(mod, probe) osi_Trace_Module_Table_Name(mod).probe
#define osi_Trace_Module_TracePoint_Table_Def_Begin(mod) \
    struct osi_Trace_Module_Table_Name(mod)
#define osi_Trace_Module_TracePoint_Table_Def_End(mod) \
    ; osi_extern struct osi_Trace_Module_Table_Name(mod) osi_Trace_Module_Table_Name(mod)
#define osi_Trace_Module_TracePoint_Table_Decl(mod) \
    struct osi_Trace_Module_Table_Name(mod) osi_Trace_Module_Table_Name(mod)


#endif /* _OSI_TRACE_COMMON_MODULE_H */
