/*
 * afstoken - pioctl interface for new common token data structures.
 *
 * revised following suggestions from lha@kth.se 20070511, 20070513
 */
/* this file is in the public domain.  Do what thou wilt. */

#if 0
package AFSTOKEN_ /* not necessary for xdr */
#endif
#if 1
#define int32_t afs_int32
#define uint64_t afs_uint64
#endif

/* this is for *small* variable sized tagged data */
const AFSTOKEN_STRING_MAX = 256;
const AFSTOKEN_DATA_MAX = 64;
struct token_tagged_data {
	int32_t tag;
	opaque tag_data<AFSTOKEN_DATA_MAX>;
};

#if 1	/* AFS_RXKAD */
const AFSTOKEN_RK_TIX_MAX = 12000;	/* not 344 FIXME should be <1500 */

struct token_rxkad {
	int32_t rk_viceid;
	int32_t rk_kvno;
	opaque rk_key[8];
	int32_t rk_begintime;
	int32_t rk_endtime;
	int32_t rk_primary_flag;
	opaque rk_ticket<AFSTOKEN_RK_TIX_MAX>;
};
#endif	/* AFS_RXKAD */

#ifdef AFS_RXGK
const AFSTOKEN_GK_TOKEN_MAX = 16384;
const AFSTOKEN_GK_KEY_MAX = 64;
struct token_rxgk {
	int32_t gk_viceid;
	uint64_t gk_begintime;
	uint64_t gk_endtime;
	int32_t gk_level;
	int32_t gk_lifetime;
	int32_t gk_bytelife;
	int32_t gk_enctype;
	opaque gk_key<AFSTOKEN_GK_KEY_MAX>;
	opaque gk_token<AFSTOKEN_GK_TOKEN_MAX>;
};
#endif	/* AFS_RXGK */

#ifdef AFS_RXK5
const AFSTOKEN_K5_COMPONENTS_MAX = 16;
const AFSTOKEN_K5_NAME_MAX = 128;
const AFSTOKEN_K5_REALM_MAX = 64;
const AFSTOKEN_K5_TIX_MAX = 16384;
const AFSTOKEN_K5_ADDRESSES_MAX = 16;
const AFSTOKEN_K5_AUTHDATA_MAX = 16;

const AFSTOKEN_BDATALN_MAX = 16384;
struct token_k5auth_data {
	int32_t tag;
	opaque big_tag_data<AFSTOKEN_BDATALN_MAX>;
};
typedef string k5component<AFSTOKEN_STRING_MAX>;
struct k5_principal {
	k5component name<AFSTOKEN_K5_COMPONENTS_MAX>;
	string k5realm<AFSTOKEN_K5_REALM_MAX>;
};
typedef opaque k5_ticket<AFSTOKEN_K5_TIX_MAX>;

struct token_rxk5 {
	k5_principal k5_client;
	k5_principal k5_server;
	token_tagged_data k5_session;
	uint64_t k5_authtime;
	uint64_t k5_starttime;
	uint64_t k5_endtime;
	uint64_t k5_renew_till;
	int32_t k5_is_skey;
	int32_t k5_flags;
	token_tagged_data k5_addresses<AFSTOKEN_K5_ADDRESSES_MAX>;
	k5_ticket k5_ticket;
	k5_ticket k5_ticket2;
	token_k5auth_data k5_authdata<AFSTOKEN_K5_AUTHDATA_MAX>;
};
#endif

const AFSTOKEN_UNION_NOAUTH = 0;
const AFSTOKEN_UNION_KAD = 2;
const AFSTOKEN_UNION_GK = 4;
const AFSTOKEN_UNION_K5 = 5;

union afstoken_soliton switch (int32_t at_type) {
#if 1	/* AFS_RXKAD */
case AFSTOKEN_UNION_KAD:
	token_rxkad at_kad;
#endif
#ifdef AFS_RXGK
case AFSTOKEN_UNION_GK:
	token_rxgk at_gk;
#endif
#ifdef AFS_RXK5
case AFSTOKEN_UNION_K5:
	token_rxk5 at_rxk5;
#endif
};

const AFSTOKEN_LENGTH_MAX = 16384;
typedef opaque token_opaque<AFSTOKEN_LENGTH_MAX>;

const AFSTOKEN_EX_SETPAG = 0x00000001; /* set tokens in new pag */
const AFSTOKEN_MAX = 8;
const AFSTOKEN_CELL_MAX = 64;

struct pioctl_set_token {
        int32_t flags;
	string cell<AFSTOKEN_CELL_MAX>;
#ifdef AFS_NT40_ENV
/* XXX should go away */
	string username<AFSTOKEN_STRING_MAX>;
	string smbname<AFSTOKEN_STRING_MAX>;
#endif
	token_opaque tokens<AFSTOKEN_MAX>;
};
