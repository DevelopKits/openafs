:
eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
	/com& eval 'exec perl -S $0 $argv:q'
	if 0;
# above code is to make perl from from perl, csh, sh
#

#
# Copyright (c) 2005
# The Regents of the University of Michigan
# ALL RIGHTS RESERVED
#
# Permission is granted to use, copy, create derivative works
# and redistribute this software and such derivative works
# for any purpose, so long as the name of the University of
# Michigan is not used in any advertising or publicity
# pertaining to the use or distribution of this software
# without specific, written prior authorization.  If the
# above copyright notice or any other identification of the
# University of Michigan is included in any copy of any
# portion of this software, then the disclaimer below must
# also be included.
#
# This software is provided as is, without representation
# from the University of Michigan as to its fitness for any
# purpose, and without warranty by the University of
# Michigan of any kind, either express or implied, including
# without limitation the implied warranties of
# merchantability and fitness for a particular purpose.  The
# regents of the University of Michigan shall not be liable
# for any damages, including special, indirect, incidental, or
# consequential damages, with respect to any claim arising
# out of or in connection with the use of the software, even
# if it has been or is hereafter advised of the possibility of
# such damages.
#

use integer;

use constant HEIMDAL => 0;
use constant AFS => 1;
use constant MIT => 2;

my $compat = AFS;

my $table_name;
my $table_number;
my $table_count;
my $table_prefix;
my @f;

sub c2n
{
	my $r, $s;
	$s = shift;
	if (length($s) > 4) {
		$s = substr($r = $s, 0, 4);
		print STDERR "Table name $r too long, truncating to $s\n";
	}
	foreach my $j ( unpack("C*",$s) ) {
		$r <<= 6;
		$r += index(
" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_",chr($j));
	}
	return ($r << 8, $s);
}

sub h_start
{
	my $outfile = shift;
print HOUT <<EOF;
/*
 * $outfile:
 * This file is automatically generated; please do not edit it.
 */
EOF
if ($compat == HEIMDAL) {
print HOUT <<HEIMDAL;

#include <et/com_err.h>

HEIMDAL
}
if ($compat == MIT) {
print HOUT <<MIT;

#include <com_err.h>

MIT
}
}

sub h_end
{
	my $table_name = shift;
	my $table_number = shift;
	my $table_count = shift;
	my $lcname= lc($table_name);
	if ($compat == AFS) {
		print HOUT <<AFS;
extern void initialize_${table_name}_error_table ();
#define ERROR_TABLE_BASE_${table_name} (${table_number}L)

/* for compatibility with older versions... */
#define init_${table_name}_err_tbl initialize_${table_name}_error_table
#define ${table_name}_err_base ERROR_TABLE_BASE_${table_name}

/* for compatibility with other users... */
#define ERROR_TABLE_BASE_${lcname} (${table_number}L)
#define init_${lcname}_err_tbl initialize_${table_name}_error_table
#define initialize_${lcname}_error_table initialize_${table_name}_error_table
#define ${lcname}_err_base ERROR_TABLE_BASE_${lcname}
AFS
	}
	if ($compat == HEIMDAL) {
		print HOUT <<HEIMDAL;
extern const struct error_table et_${table_name}_error_table;
extern void initialize_${table_name}_error_table(void);

/* For compatibility with Heimdal */
extern void initialize_${table_name}_error_table_r(struct et_list **list);

#define ERROR_TABLE_BASE_${table_name} (${table_number}L)

/* for compatibility with older versions... */
#define init_${table_name}_err_tbl initialize_${table_name}_error_table
#define ${table_name}_err_base ERROR_TABLE_BASE_${table_name}
HEIMDAL
	}
	if ($compat == MIT) {
		print HOUT <<MIT;
#define ERROR_TABLE_BASE_${table_name} (${table_number}L)

extern const struct error_table et_${table_name}_error_table;

#if !defined(_WIN32)
/* for compatibility with older versions... */
extern void initialize_${table_name}_error_table(void);
#else
#define initialize_${table_name}_error_table()
#endif

#if !defined(_WIN32)
#define init_${table_name}_err_tbl initialize_${table_name}_error_table
#define ${table_name}_err_base ERROR_TABLE_BASE_${table_name}
#endif
MIT
	}
}

sub c_start
{
	my $outfile = shift;
print COUT <<EOF;
/*
 * $outfile:
 * This file is automatically generated; please do not edit it.
 */
EOF
	if ($compat == AFS) {
		print COUT <<EOF;
#include <afs/param.h>
#include <afs/error_table.h>
EOF
	}
	if ($compat == HEIMDAL) {
		print COUT <<HEIMDAL;

#include <stdlib.h>

HEIMDAL
	}
	if ($compat == MIT) {
		print COUT <<MIT;
#if !defined(_WIN32)
extern void initialize_${table_name}_error_table (void);
#endif
MIT
	}
	print COUT <<EOF;
static const char * const text[] = {
EOF
}

sub c_end
{
	my $table_name = shift;
	my $table_number = shift;
	my $table_count = shift;
	my $et_name = $compat==AFS ? "et" : "et_${table_name}_error_table";
	my $heimdal_nospace = $compat!=HEIMDAL ? " " : "";
print COUT <<EOF;
    0
};

EOF
	if ($compat == HEIMDAL) {
		print COUT <<HEIMDAL;
struct error_table {
    char const * const * msgs;
    long base;
    int n_msgs;
};
struct et_list {
    struct et_list *next;
    const struct error_table * table;
};
extern struct et_list *_et_list;

HEIMDAL
	}
	if ($compat == MIT) {
print COUT <<MIT;
#include <com_err.h>

MIT
	}
if ($compat == AFS) {
print COUT "static ";
}
print COUT <<EOF;
const struct error_table ${et_name} = { text, ${table_number}L, ${table_count} };

EOF
if ($compat == AFS) {
print COUT <<AFS;
static struct et_list etlink = { 0, &${et_name}};

AFS
}
if ($compat == HEIMDAL) {
print COUT <<HEIMDAL;
static struct et_list link = { 0, 0 };

void initialize_${table_name}_error_table(void);

HEIMDAL
}
	if ($compat == MIT) {
print COUT <<MIT;
#if !defined(_WIN32)
MIT
	}
print COUT <<EOF;
void initialize_${table_name}_error_table${heimdal_nospace}(void) {
EOF
if ($compat == AFS) {
print COUT <<AFS;
    afs_add_to_error_table(&etlink);
AFS
}
if ($compat == HEIMDAL) {
print COUT <<HEIMDAL;
    if (!link.table) {
        link.next = _et_list;
        link.table = &${et_name};
        _et_list = &link;
    }
HEIMDAL
}
if ($compat == MIT) {
print COUT <<MIT;
    (void) add_error_table (&${et_name});
MIT
}
print COUT <<EOF;
}
EOF
if ($compat == HEIMDAL) {
print COUT <<HEIMDAL;

/* For Heimdal compatibility */
void initialize_${table_name}_error_table_r(struct et_list **list);

void initialize_${table_name}_error_table_r(struct et_list **list)
{
    struct et_list *et, **end;

    for (end = list, et = *list; et; end = &et->next, et = et->next)
        if (et->table->msgs == text)
            return;
    et = malloc(sizeof(struct et_list));
    if (et == 0)
        return;
    et->table = &${et_name};
    et->next = 0;
    *end = et;
}
HEIMDAL
}
	if ($compat == MIT) {
print COUT <<MIT;
#endif
MIT
	}
}

sub do_error_table
{
	($outfile = $ARGV) =~ s/\.et$//;
	$outfile =~ s/.*\///;
	open COUT, '>'.$outfile.".c" || die "Cannot open $outfile.c: $!";
	open HOUT, '>'.$outfile.".h" || die "Cannot open $outfile.h: $!";
	($table_number, $table_name) = c2n($f[1]);
	$table_count = 0;
	c_start($outfile.'.c');
	h_start($outfile.'.h');
}

sub do_end
{
	c_end($table_name, $table_number, $table_count);
	h_end($table_name, $table_number, $table_count);
}

sub process_text
{
	my $text = shift;
	chomp($text);
	$text =~ s/\s*#[^"]*$//;
	print COUT "$text";
	$continuation = ($text =~ /\\$/) ? "" : undef;
	print COUT "," unless(defined($continuation));
	print COUT "\n";
}

sub do_ec
{
	my $ec;
	my $word;
	($ec, $text) = split(' ', $_, 2);
	($word, $text) = split(/[, ]/, $text, 2);
	$word = $table_prefix.$word;
	if (length($word) < 40) {
		$word = substr($word.' ' x 40, 0, 40);
	}
	print HOUT "\#define $word (".($table_number+$table_count)."L)\n"; 
	++$table_count;
	$text =~ s/^\s*//;
	if ($text =~ /^\"/) {
		process_text("\t".$text);
	} else {
		$continuation = "\t";
	}
}

sub do_prefix
{
	if ($f[1]) {
		$table_prefix = $f[1].'_';
	} else {
		$table_prefix = '';
	}
}

sub do_index
{
	my $count = $f[1];
	my $j;
	for $j ( $table_count..($count-1)) {
		print COUT <<EOF;
	"Reserved ${table_name} error ($j)",
EOF
	}
	$table_count = $count;
}

sub do_id
{
	my $id;
	($id, $text) = split(' ', $_, 2);
}

%do_actions = (
	et => \&do_error_table,
	error_table => \&do_error_table,
	ec => \&do_ec,
	error_code => \&do_ec,
	end => \&do_end,
	index => \&do_index,
	prefix => \&do_prefix,
	id => \&do_id,
);

{
	my @out;
	foreach $x ( @ARGV ) {
		if ($x eq '-heimdal') {
			$compat = HEIMDAL;
			next;
		}
		if ($x eq '-afs') {
			$compat = AFS;
			next;
		}
		if ($x eq '-mit') {
			$compat = MIT;
			next;
		}
		push @out, $x;
	}
	@ARGV = @out;
}

while (<>)
{
	if (defined($continuation)) {
		process_text($continuation.$_);
		next;
	}
	/^\s*[#]/ && next;
	/^\s*$/ && next;
	@f = split;
	my $action;
	if ($action = $do_actions{$f[0]}) {
		&$action;
		next;
	}
	print STDERR "$ARGV($.): don't know how to do $f[0] - <$_>\n";
}
